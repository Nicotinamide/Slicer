#include "model_io.h"
#include "model3d.h" // for Model3D
#include <fstream>
#include <iostream>
#include <sstream>
#include <filesystem>


// 辅助函数：去除字符串前后空白
static inline std::string trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

// 辅助函数：转换字符串为小写
static inline std::string toLower(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(), 
                  [](unsigned char c) { return std::tolower(c); });
    return result;
}

// 辅助函数：检查字符串是否以指定前缀开始
static inline bool startsWith(const std::string& str, const std::string& prefix) {
    return str.size() >= prefix.size() && 
           std::equal(prefix.begin(), prefix.end(), str.begin());
}

// 辅助函数：更新包围盒
void updateBoundingBox(Vec3& min, Vec3& max, const Vec3& point) {
    min.x = (min.x < point.x) ? min.x : point.x;
    min.y = (min.y < point.y) ? min.y : point.y;
    min.z = (min.z < point.z) ? min.z : point.z;
    
    max.x = (max.x > point.x) ? max.x : point.x;
    max.y = (max.y > point.y) ? max.y : point.y;
    max.z = (max.z > point.z) ? max.z : point.z;
}

// 计算两点间距离
float distance(const Vec3& a, const Vec3& b) {
    return (a - b).length();
}

ModelIO::ModelIO(Model3D* model) : m_model(model) {
}

bool ModelIO::loadModel(const std::string& filePath) {
    // 清除之前的数据
    m_model->clear();
    
    // 检测文件类型
    ModelType fileType = detectFileType(filePath);
    
    // 输出文件类型
    std::cout << "File type: " << static_cast<int>(fileType) << std::endl;

    // 保存文件目录路径(用于查找关联文件)
    size_t lastSlash = filePath.find_last_of("/\\");
    if (lastSlash != std::string::npos) {
        m_model->m_directory = filePath.substr(0, lastSlash + 1);
    }
    
    // 根据文件类型调用相应的读取函数
    bool success = false;
    switch (fileType) {
        case ModelType::STL_ASCII:
            success = readSTLAscii(filePath);
            break;
        case ModelType::STL_BINARY:
            success = readSTLBinary(filePath);
            break;
        case ModelType::OBJ:
            success = readOBJ(filePath);
            break;
        default:
            std::cerr << "不支持的文件格式!" << std::endl;
            return false;
    }
    
    if (success) {
        // 更新模型类型
        m_model->m_modelType = fileType;
        
        // 处理加载的网格 - 可以调用其他组件的功能
        for (auto& mesh : m_model->getMeshes()) {
            // 例如: m_model->calculateNormals(mesh);
        }
    }
    
    return success;
}

// 导出为STL文件
bool ModelIO::exportToSTL(const std::string& filePath, const std::vector<Mesh>& meshes, bool binary, bool mergeMeshes) const {
    if (meshes.empty()) {
        std::cerr << "没有可导出的网格数据!" << std::endl;
        return false;
    }
    
    if (mergeMeshes && meshes.size() > 1) {
        // TODO: 合并所有网格后导出
        // Mesh mergedMesh = m_model->m_meshOptimizer->mergeMeshes(m_model->m_meshes);
        // return exportMeshToSTL(filePath, mergedMesh, binary);
        
        // 临时处理: 只导出第一个网格
        std::cout << "合并多个网格功能尚未实现, 只导出第一个网格" << std::endl;
        return exportMeshToSTL(filePath, meshes[0], binary);
    }
    else {
        // 依次导出每个网格
        bool allSuccess = true;
        for (size_t i = 0; i < meshes.size(); i++) {
            std::string meshFilePath = filePath;
            if (meshes.size() > 1) {
                // 如果有多个网格, 为每个文件添加索引
                size_t dotPos = filePath.find_last_of('.');
                if (dotPos != std::string::npos) {
                    meshFilePath = filePath.substr(0, dotPos) + "_" + std::to_string(i) + filePath.substr(dotPos);
                }
                else {
                    meshFilePath = filePath + "_" + std::to_string(i);
                }
            }

            if (!exportMeshToSTL(meshFilePath, meshes[i], binary)) {
                allSuccess = false;
            }
        }
        return allSuccess;
    }
}

// 导出为OBJ文件
bool ModelIO::exportToOBJ(const std::string& filePath, const std::vector<Mesh>& meshes) const {
    if (meshes.empty()) {
        std::cerr << "没有可导出的网格数据!" << std::endl;
        return false;
    }
    
    // 创建OBJ和MTL文件
    std::string mtlFilePath;
    size_t dotPos = filePath.find_last_of('.');
    if (dotPos != std::string::npos) {
        mtlFilePath = filePath.substr(0, dotPos) + ".mtl";
    }
    else {
        mtlFilePath = filePath + ".mtl";
    }
    
    std::ofstream objFile(filePath);
    std::ofstream mtlFile(mtlFilePath);
    
    if (!objFile.is_open() || !mtlFile.is_open()) {
        std::cerr << "无法创建输出文件!" << std::endl;
        return false;
    }
    
    // 写入OBJ文件头
    objFile << "# OBJ file generated by Model3D\n";
    objFile << "mtllib " << mtlFilePath.substr(mtlFilePath.find_last_of("/\\") + 1) << "\n\n";
    
    // 顶点索引偏移量
    int vertexOffset = 1;  // OBJ文件索引从1开始
    int normalOffset = 1;
    int texCoordOffset = 1;
    
    // 处理每个网格
    for (size_t meshIdx = 0; meshIdx < meshes.size(); meshIdx++) {
        const Mesh& mesh = meshes[meshIdx];

        // 添加网格头部
        objFile << "# Mesh: " << mesh.name << "\n";
        objFile << "g " << (mesh.name.empty() ? "mesh_" + std::to_string(meshIdx) : mesh.name) << "\n";
        objFile << "usemtl " << (mesh.material.name.empty() ? "material_" + std::to_string(meshIdx) : mesh.material.name) << "\n\n";
        
        // 导出顶点数据
        for (const auto& vertex : mesh.vertices) {
            objFile << "v " << vertex.position.x << " " << vertex.position.y << " " << vertex.position.z << "\n";
            
            if (vertex.normal.squared_length() > 0) {
                objFile << "vn " << vertex.normal.x << " " << vertex.normal.y << " " << vertex.normal.z << "\n";
            }
            
            if (vertex.texCoord.x != 0 || vertex.texCoord.y != 0) {
                objFile << "vt " << vertex.texCoord.x << " " << vertex.texCoord.y << "\n";
            }
        }
        
        // 导出三角形数据
        objFile << "\n# Faces\n";
        for (const auto& tri : mesh.triangles) {
            objFile << "f ";
            for (int i = 0; i < 3; i++) {
                int idx = tri.indices[i] + vertexOffset;
                objFile << idx << "/" << idx << "/" << idx << " ";
            }
            objFile << "\n";
        }
        
        // 更新索引偏移量
        vertexOffset += mesh.vertices.size();
        normalOffset += mesh.vertices.size();  // 假设法线和顶点数量一致
        texCoordOffset += mesh.vertices.size();  // 假设纹理坐标和顶点数量一致
        
        // 导出材质信息到MTL文件
        mtlFile << "# Material for mesh: " << mesh.name << "\n";
        mtlFile << "newmtl " << (mesh.material.name.empty() ? "material_" + std::to_string(meshIdx) : mesh.material.name) << "\n";
        mtlFile << "Ka " << mesh.material.ambient.r << " " << mesh.material.ambient.g << " " << mesh.material.ambient.b << "\n";
        mtlFile << "Kd " << mesh.material.diffuse.r << " " << mesh.material.diffuse.g << " " << mesh.material.diffuse.b << "\n";
        mtlFile << "Ks " << mesh.material.specular.r << " " << mesh.material.specular.g << " " << mesh.material.specular.b << "\n";
        mtlFile << "Ns " << mesh.material.shininess << "\n";
        
        if (!mesh.material.diffuseMap.empty()) {
            mtlFile << "map_Kd " << mesh.material.diffuseMap << "\n";
        }
        
        if (!mesh.material.normalMap.empty()) {
            mtlFile << "map_bump " << mesh.material.normalMap << "\n";
        }
        
        mtlFile << "\n";
    }
    
    objFile.close();
    mtlFile.close();
    
    std::cout << "成功导出OBJ文件: " << filePath << std::endl;
    std::cout << "成功导出MTL文件: " << mtlFilePath << std::endl;
    
    return true;
}

// 导出单个网格到STL文件
bool ModelIO::exportMeshToSTL(const std::string& filePath, const Mesh& mesh, bool binary) const {
    if (mesh.vertices.empty() || mesh.triangles.empty()) {
        std::cerr << "网格数据为空!" << std::endl;
        return false;
    }
    
    if (binary) {
        // 二进制STL格式
        std::ofstream file(filePath, std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "无法创建STL文件: " << filePath << std::endl;
            return false;
        }
        
        // 写入头部(80字节)
        char header[80] = {0};
        sprintf(header, "STL file generated by Model3D - Mesh: %s", mesh.name.c_str());
        file.write(header, 80);
        
        // 写入三角形数量(4字节)
        uint32_t numTriangles = static_cast<uint32_t>(mesh.triangles.size());
        file.write(reinterpret_cast<char*>(&numTriangles), 4);
        
        // 写入每个三角形的数据
        for (const auto& tri : mesh.triangles) {
            // 获取三角形的顶点
            const Vec3& v0 = mesh.vertices[tri.indices[0]].position;
            const Vec3& v1 = mesh.vertices[tri.indices[1]].position;
            const Vec3& v2 = mesh.vertices[tri.indices[2]].position;
            
            // 法线(使用三角形的法线或计算)
            Vec3 normal = tri.normal;
            if (normal.squared_length() == 0) {
                normal = calculateTriangleNormal(v0, v1, v2);
            }
            
            // 写入法线
            float nx = normal.x;
            float ny = normal.y;
            float nz = normal.z;
            file.write(reinterpret_cast<char*>(&nx), 4);
            file.write(reinterpret_cast<char*>(&ny), 4);
            file.write(reinterpret_cast<char*>(&nz), 4);
            
            // 写入顶点
            float x, y, z;
            x = v0.x; y = v0.y; z = v0.z;
            file.write(reinterpret_cast<char*>(&x), 4);
            file.write(reinterpret_cast<char*>(&y), 4);
            file.write(reinterpret_cast<char*>(&z), 4);
            
            x = v1.x; y = v1.y; z = v1.z;
            file.write(reinterpret_cast<char*>(&x), 4);
            file.write(reinterpret_cast<char*>(&y), 4);
            file.write(reinterpret_cast<char*>(&z), 4);
            
            x = v2.x; y = v2.y; z = v2.z;
            file.write(reinterpret_cast<char*>(&x), 4);
            file.write(reinterpret_cast<char*>(&y), 4);
            file.write(reinterpret_cast<char*>(&z), 4);
            
            // 写入属性字节数(2字节, 通常为0)
            uint16_t attrByteCount = 0;
            file.write(reinterpret_cast<char*>(&attrByteCount), 2);
        }
        
        file.close();
    }
    else {
        // ASCII STL格式
        std::ofstream file(filePath);
        if (!file.is_open()) {
            std::cerr << "无法创建STL文件: " << filePath << std::endl;
            return false;
        }
        
        file << "solid " << mesh.name << "\n";
        
        for (const auto& tri : mesh.triangles) {
            // 获取三角形的顶点
            const Vec3& v0 = mesh.vertices[tri.indices[0]].position;
            const Vec3& v1 = mesh.vertices[tri.indices[1]].position;
            const Vec3& v2 = mesh.vertices[tri.indices[2]].position;
            
            // 法线(使用三角形的法线或计算)
            Vec3 normal = tri.normal;
            if (normal.squared_length() == 0) {
                normal = calculateTriangleNormal(v0, v1, v2);
            }
            
            file << "  facet normal " << normal.x << " " << normal.y << " " << normal.z << "\n";
            file << "    outer loop\n";
            file << "      vertex " << v0.x << " " << v0.y << " " << v0.z << "\n";
            file << "      vertex " << v1.x << " " << v1.y << " " << v1.z << "\n";
            file << "      vertex " << v2.x << " " << v2.y << " " << v2.z << "\n";
            file << "    endloop\n";
            file << "  endfacet\n";
        }
        
        file << "endsolid " << mesh.name << "\n";
        file.close();
    }
    
    std::cout << "成功导出STL文件: " << filePath << std::endl;
    return true;
}

// 导出单个网格到OBJ文件 (简化版)
bool ModelIO::exportMeshToOBJ(const std::string& filePath, const Mesh& mesh) const {
    std::vector<Mesh> singleMesh = { mesh };
    
    // 创建临时Model3D对象
    Model3D tempModel;
    for (auto& m : singleMesh) {
        tempModel.getMeshes().push_back(m);
    }
    
    // 使用exportToOBJ方法
    ModelIO tempIO(&tempModel);
    return tempIO.exportToOBJ(filePath, singleMesh);
}

ModelType ModelIO::detectFileType(const std::string& filePath) {
// 首先通过扩展名判断
    std::string extension = std::filesystem::path(filePath).extension().string();
    std::transform(extension.begin(), extension.end(), extension.begin(),
                  [](unsigned char c) { return std::tolower(c); });
    
    if (extension == ".stl") {
        // 尝试区分是ASCII还是二进制STL
        std::ifstream file(filePath, std::ios::binary);
        if (!file.good()) {
            return ModelType::UNKNOWN;
        }
        
        // 读取前6个字符，检查是否以"solid"开头
        char header[6] = {0};
        file.read(header, 5);
        
        if (std::strncmp(header, "solid", 5) == 0) {
            // 大多数ASCII STL以"solid"开头，但有些二进制STL也可能以"solid"开头
            // 为了更加确定，我们需要进一步检查
            file.seekg(0, std::ios::end);
            std::streamsize fileSize = file.tellg();
            file.seekg(0, std::ios::beg);
            
            // 如果文件大小精确地等于二进制STL的预期大小，很可能是二进制STL
            // 二进制STL结构：80字节头 + 4字节三角形数量 + 每个三角形50字节
            if ((fileSize - 84) % 50 == 0) {
                // 再次检查一下，从第80个字节开始读取4字节作为三角形数量
                file.seekg(80, std::ios::beg);
                uint32_t triangleCount;
                file.read(reinterpret_cast<char*>(&triangleCount), sizeof(triangleCount));
                
                // 测试文件大小是否匹配预期的三角形数量
                if (fileSize == 84 + (triangleCount * 50)) {
                    return ModelType::STL_BINARY;
                }
            }
            
            return ModelType::STL_ASCII;
        } 
        else {
            return ModelType::STL_BINARY;
        }
    } 
    else if (extension == ".obj") {
        return ModelType::OBJ;
    }
    
    return ModelType::UNKNOWN;
}

// 读取ASCII STL文件
bool ModelIO::readSTLAscii(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.good()) {
        std::cerr << "无法打开STL文件: " << filePath << std::endl;
        return false;
    }
    
    std::string line;
    std::string solidName;
    
    // 读取solid行，获取名称
    if (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string token;
        iss >> token;
        
        if (toLower(token) != "solid") {
            std::cerr << "STL文件格式错误: 缺少'solid'关键字" << std::endl;
            return false;
        }
        
        // 提取solid名称
        solidName = line.substr(5);
        solidName = trim(solidName);
    }
    
    // 创建新的网格
    Mesh mesh;
    mesh.name = solidName.empty() ? "unnamed_stl" : solidName;
    
    Vec3 normal(0.0f, 0.0f, 0.0f);
    bool inFacet = false;
    bool inLoop = false;
    int vertexCount = 0;
    Triangle currentTriangle;
    
    // 逐行解析文件
    while (std::getline(file, line)) {
        std::istringstream iss(trim(line));
        std::string token;
        iss >> token;
        token = toLower(token);
        
        if (token == "facet") {
            if (inFacet) {
                std::cerr << "STL格式错误: 嵌套的facet" << std::endl;
                return false;
            }
            
            inFacet = true;
            vertexCount = 0;
            
            // 读取法线
            std::string normalToken;
            iss >> normalToken;
            
            if (toLower(normalToken) == "normal") {
                iss >> normal.x >> normal.y >> normal.z;
                currentTriangle.normal = normal;
            } else {
                std::cerr << "STL格式错误: 'facet'后缺少'normal'" << std::endl;
                return false;
            }
        } 
        else if (token == "outer") {
            if (!inFacet || inLoop) {
                std::cerr << "STL格式错误: 'outer'关键字位置不正确" << std::endl;
                return false;
            }
            
            std::string loopToken;
            iss >> loopToken;
            
            if (toLower(loopToken) != "loop") {
                std::cerr << "STL格式错误: 'outer'后缺少'loop'" << std::endl;
                return false;
            }
            
            inLoop = true;
        } 
        else if (token == "vertex") {
            if (!inLoop) {
                std::cerr << "STL格式错误: 'vertex'关键字在loop外部" << std::endl;
                return false;
            }
            
            if (vertexCount >= 3) {
                std::cerr << "STL格式错误: 每个facet超过3个顶点" << std::endl;
                return false;
            }
            
            Vertex v;
            iss >> v.position.x >> v.position.y >> v.position.z;
            v.normal = normal; // 使用面法线作为顶点法线
            v.color = Vec3(0.8f, 0.8f, 0.8f); // 默认颜色
            
            // 更新包围盒
            updateBoundingBox(m_model->m_boundingBoxMin, m_model->m_boundingBoxMax, v.position);

            // 添加顶点到网格
            mesh.vertices.push_back(v);
            
            // 记录顶点索引
            currentTriangle.indices[vertexCount] = mesh.vertices.size() - 1;
            vertexCount++;
        } 
        else if (token == "endloop") {
            if (!inLoop) {
                std::cerr << "STL格式错误: 'endloop'关键字无对应的'loop'" << std::endl;
                return false;
            }
            
            inLoop = false;
        } 
        else if (token == "endfacet") {
            if (!inFacet) {
                std::cerr << "STL格式错误: 'endfacet'关键字无对应的'facet'" << std::endl;
                return false;
            }
            
            inFacet = false;
            
            // 添加当前三角形
            if (vertexCount == 3) {
                mesh.triangles.push_back(currentTriangle);
                
                // 添加索引到索引数组
                mesh.indices.push_back(currentTriangle.indices[0]);
                mesh.indices.push_back(currentTriangle.indices[1]);
                mesh.indices.push_back(currentTriangle.indices[2]);
            } else {
                std::cerr << "STL格式错误: facet未包含3个顶点" << std::endl;
                return false;
            }
        } 
        else if (token == "endsolid") {
            // 存储完成的网格
            m_model->m_meshes.push_back(mesh);
            return true;
        }
    }
    
    // 如果没有正确读到"endsolid"，文件可能不完整
    std::cerr << "STL格式错误: 缺少'endsolid'关键字" << std::endl;
    return false;
}

// 读取二进制STL文件
bool ModelIO::readSTLBinary(const std::string& filePath) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file.good()) {
        std::cerr << "无法打开STL文件: " << filePath << std::endl;
        return false;
    }
    
    // 创建新网格
    Mesh mesh;
    mesh.name = std::filesystem::path(filePath).stem().string(); // 使用文件名作为网格名称
    
    // 读取80字节的头部信息(通常不使用)
    char header[80] = {0};
    file.read(header, 80);
    
    // 头部可能包含solid名称，尝试提取(这是个启发式方法，并非标准)
    header[79] = '\0'; // 确保以null结尾
    if (std::strlen(header) > 0) {
        mesh.name = header;
    }
    
    // 读取三角形数量
    uint32_t triangleCount = 0;
    file.read(reinterpret_cast<char*>(&triangleCount), sizeof(triangleCount));
    
    if (triangleCount == 0) {
        std::cerr << "STL文件不包含任何三角形" << std::endl;
        return false;
    }
    
    // 预留空间
    mesh.vertices.reserve(triangleCount * 3); // 最坏情况：每个三角形3个唯一顶点
    mesh.triangles.reserve(triangleCount);
    mesh.indices.reserve(triangleCount * 3);
    
    // 读取所有三角形
    for (uint32_t i = 0; i < triangleCount; ++i) {
        // 二进制STL三角形结构：
        // - 法线(3个float): 12字节
        // - 3个顶点(每个3个float): 36字节
        // - 2字节属性(通常不使用)
        // 总共: 50字节/三角形
        
        // 读取法线
        Vec3 normal;
        file.read(reinterpret_cast<char*>(&normal.x), sizeof(float) * 3);
        
        Triangle triangle;
        triangle.normal = normal;
        
        // 读取3个顶点
        for (int j = 0; j < 3; ++j) {
            Vertex vertex;
            file.read(reinterpret_cast<char*>(&vertex.position.x), sizeof(float) * 3);
            
            vertex.normal = normal; // 使用面法线
            vertex.color = Vec3(0.8f, 0.8f, 0.8f); // 默认颜色
            
            // 更新包围盒
            updateBoundingBox(m_model->m_boundingBoxMin, m_model->m_boundingBoxMax, vertex.position);

            // 添加顶点
            mesh.vertices.push_back(vertex);
            
            // 记录顶点索引
            triangle.indices[j] = mesh.vertices.size() - 1;
            
            // 添加到索引数组
            mesh.indices.push_back(triangle.indices[j]);
        }
        
        // 读取2字节属性值(通常不使用)
        uint16_t attributeByteCount;
        file.read(reinterpret_cast<char*>(&attributeByteCount), sizeof(attributeByteCount));
        
        // 添加三角形到网格
        mesh.triangles.push_back(triangle);
    }
    
    // 检查是否读取完整
    if (!file.eof() && !file.good()) {
        std::cerr << "读取二进制STL文件时出错" << std::endl;
        return false;
    }
    
    // 优化网格(合并重复顶点)
    m_model->optimizeMesh(mesh);

    // 添加网格到集合
    m_model->m_meshes.push_back(mesh);

    return true;
}

// 读取OBJ文件
bool ModelIO::readOBJ(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.good()) {
        std::cerr << "无法打开OBJ文件: " << filePath << std::endl;
        return false;
    }
    
    // 创建默认网格
    Mesh currentMesh;
    currentMesh.name = std::filesystem::path(filePath).stem().string();
    
    // 临时存储所有顶点、法线和纹理坐标数据
    std::vector<Vec3> positions;
    std::vector<Vec3> normals;
    std::vector<Vec2> texCoords;
    
    // 当前材质名称
    std::string currentMaterialName;
    
    std::string line;
    while (std::getline(file, line)) {
        // 跳过空行和注释
        line = trim(line);
        if (line.empty() || line[0] == '#')
            continue;
        
        std::istringstream iss(line);
        std::string token;
        iss >> token;
        
        if (token == "v") {
            // 顶点位置
            Vec3 position;
            iss >> position.x >> position.y >> position.z;
            
            // 更新包围盒
            updateBoundingBox(m_model->m_boundingBoxMin, m_model->m_boundingBoxMax, position);

            positions.push_back(position);
        }
        else if (token == "vn") {
            // 顶点法线
            Vec3 normal;
            iss >> normal.x >> normal.y >> normal.z;
            normals.push_back(normal.normalize());
        }
        else if (token == "vt") {
            // 纹理坐标
            Vec2 texCoord;
            iss >> texCoord.x >> texCoord.y;
            texCoords.push_back(texCoord);
        }
        else if (token == "f") {
            // 面数据
            std::vector<int> posIndices;
            std::vector<int> texIndices;
            std::vector<int> normalIndices;
            
            std::string vertex;
            // 解析面的每个顶点
            while (iss >> vertex) {
                std::istringstream viss(vertex);
                std::string indexStr;
                
                // 格式可能是：v、v/vt、v/vt/vn 或 v//vn
                // v: 顶点索引
                // vt: 纹理坐标索引
                // vn: 法线索引
                
                // 顶点位置索引
                std::getline(viss, indexStr, '/');
                if (!indexStr.empty()) {
                    int index = std::stoi(indexStr);
                    // OBJ索引从1开始，转换为从0开始
                    index = (index > 0) ? index - 1 : positions.size() + index;
                    posIndices.push_back(index);
                }
                
                // 纹理坐标索引
                std::getline(viss, indexStr, '/');
                if (!indexStr.empty()) {
                    int index = std::stoi(indexStr);
                    index = (index > 0) ? index - 1 : texCoords.size() + index;
                    texIndices.push_back(index);
                }
                
                // 法线索引
                std::getline(viss, indexStr);
                if (!indexStr.empty()) {
                    int index = std::stoi(indexStr);
                    index = (index > 0) ? index - 1 : normals.size() + index;
                    normalIndices.push_back(index);
                }
            }
            
            // 确认是否有足够的顶点构成一个多边形
            if (posIndices.size() >= 3) {
                // 添加顶点到当前网格
                for (size_t i = 0; i < posIndices.size(); ++i) {
                    Vertex v;
                    v.position = positions[posIndices[i]];
                    
                    // 如果有法线数据
                    if (i < normalIndices.size() && normalIndices[i] >= 0 && normalIndices[i] < normals.size()) {
                        v.normal = normals[normalIndices[i]];
                    }
                    
                    // 如果有纹理坐标数据
                    if (i < texIndices.size() && texIndices[i] >= 0 && texIndices[i] < texCoords.size()) {
                        v.texCoord = texCoords[texIndices[i]];
                    }
                    
                    v.color = Vec3(0.8f, 0.8f, 0.8f); // 默认颜色
                    
                    // 添加到网格
                    currentMesh.vertices.push_back(v);
                }
                
                // 三角形化多边形(面可能是三角形、四边形或更多边的多边形)
                for (size_t i = 2; i < posIndices.size(); ++i) {
                    Triangle triangle;
                    triangle.indices[0] = currentMesh.vertices.size() - posIndices.size();
                    triangle.indices[1] = currentMesh.vertices.size() - posIndices.size() + i - 1;
                    triangle.indices[2] = currentMesh.vertices.size() - posIndices.size() + i;
                    
                    // 计算面法线
                    const auto& v0 = currentMesh.vertices[triangle.indices[0]].position;
                    const auto& v1 = currentMesh.vertices[triangle.indices[1]].position;
                    const auto& v2 = currentMesh.vertices[triangle.indices[2]].position;
                    triangle.normal = calculateTriangleNormal(v0, v1, v2);
                    
                    // 添加三角形
                    currentMesh.triangles.push_back(triangle);
                    
                    // 添加到索引数组
                    currentMesh.indices.push_back(triangle.indices[0]);
                    currentMesh.indices.push_back(triangle.indices[1]);
                    currentMesh.indices.push_back(triangle.indices[2]);
                }
            }
        }
        else if (token == "mtllib") {
            // 材质库
            std::string mtlFileName;
            iss >> mtlFileName;
            
            // 读取材质文件
            std::string mtlFilePath = (std::filesystem::path(filePath).parent_path() / mtlFileName).string();
            readMTL(mtlFilePath);
        }
        else if (token == "usemtl") {
            // 使用材质
            std::string materialName;
            iss >> materialName;
            
            // 如果材质变化了，可能需要创建新网格
            // 这里简化处理，只修改当前网格的材质名称
            if (!materialName.empty() && materialName != currentMaterialName) {
                currentMaterialName = materialName;
                
                // 设置材质
                if (m_model->m_materials.find(materialName) != m_model->m_materials.end()) {
                    currentMesh.material = m_model->m_materials[materialName];
                }
            }
        }
        else if (token == "o" || token == "g") {
            // 对象或组名称
            std::string name;
            std::getline(iss, name);
            name = trim(name);
            
            // 如果当前网格已有数据，保存它并创建新网格
            if (!currentMesh.vertices.empty() && !currentMesh.indices.empty()) {
                // 优化当前网格
                m_model->optimizeMesh(currentMesh);
                
                // 保存当前网格
                m_model->m_meshes.push_back(currentMesh);

                // 创建新网格
                currentMesh = Mesh();
                currentMesh.name = name;
                
                // 保持当前材质
                if (!currentMaterialName.empty() && m_model->m_materials.find(currentMaterialName) != m_model->m_materials.end()) {
                    currentMesh.material = m_model->m_materials[currentMaterialName];
                }
            } 
            else {
                // 仅更新网格名称
                currentMesh.name = name;
            }
        }
    }



    // 保存最后一个网格
    if (!currentMesh.vertices.empty() && !currentMesh.indices.empty()) {
        // 优化当前网格
        m_model->optimizeMesh(currentMesh);

        // 保存当前网格
        m_model->m_meshes.push_back(currentMesh);
    }
    
    // 如果没有读取到任何网格，返回失败
    if (m_model->m_meshes.empty()) {
        std::cerr << "OBJ文件不包含有效网格数据" << std::endl;
        return false;
    }
    
    return true;
}

// 读取MTL材质文件
bool ModelIO::readMTL(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.good()) {
        std::cerr << "无法打开MTL文件: " << filePath << std::endl;
        return false;
    }
    
    Material* currentMaterial = nullptr;
    
    std::string line;
    while (std::getline(file, line)) {
        line = trim(line);
        if (line.empty() || line[0] == '#') continue;
        
        std::istringstream iss(line);
        std::string token;
        iss >> token;
        
        if (token == "newmtl") {
            // 新材质
            std::string name;
            std::getline(iss, name);
            name = trim(name);
            
            if (!name.empty()) {
                m_model->m_materials[name] = Material();
                currentMaterial = &m_model->m_materials[name];
                currentMaterial->name = name;
            }
        }
        else if (token == "Ka" && currentMaterial) {
            // 环境光颜色
            iss >> currentMaterial->ambient.r >> currentMaterial->ambient.g >> currentMaterial->ambient.b;
        }
        else if (token == "Kd" && currentMaterial) {
            // 漫反射颜色
            iss >> currentMaterial->diffuse.r >> currentMaterial->diffuse.g >> currentMaterial->diffuse.b;
        }
        else if (token == "Ks" && currentMaterial) {
            // 镜面反射颜色
            iss >> currentMaterial->specular.r >> currentMaterial->specular.g >> currentMaterial->specular.b;
        }
        else if (token == "Ns" && currentMaterial) {
            // 镜面反射指数
            iss >> currentMaterial->shininess;
        }
        else if (token == "map_Kd" && currentMaterial) {
            // 漫反射贴图
            std::string texPath;
            std::getline(iss, texPath);
            texPath = trim(texPath);
            
            if (!texPath.empty()) {
                // 尝试解析贴图路径
                std::filesystem::path mapPath(texPath);
                std::string mapFilename = mapPath.filename().string();
                
                // 在模型目录下查找贴图
                std::string fullPath = m_model->m_directory + "/" + mapFilename;
                
                if (std::filesystem::exists(fullPath)) {
                    currentMaterial->diffuseMap = fullPath;
                } else {
                    currentMaterial->diffuseMap = texPath; // 使用原始路径
                }
            }
        }
        else if (token == "map_Bump" && currentMaterial) {
            // 法线贴图
            std::string texPath;
            std::getline(iss, texPath);
            texPath = trim(texPath);
            
            if (!texPath.empty()) {
                std::filesystem::path mapPath(texPath);
                std::string mapFilename = mapPath.filename().string();
                
                std::string fullPath = m_model->m_directory + "/" + mapFilename;
                
                if (std::filesystem::exists(fullPath)) {
                    currentMaterial->normalMap = fullPath;
                } else {
                    currentMaterial->normalMap = texPath;
                }
            }
        }
    }
    
    return true;
}
